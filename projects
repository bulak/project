#!/usr/bin/env bash

# projects --
# TODO
# -----------------------------------------

:<<'LICENSE'
MIT License

Copyright (c) 2018 A. Bulak Arpat

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
LICENSE

# Constants
DESCR="\"projects\" is a simple shell script that manages tmux based projects"
VERSION="3.2"

PROJECTS_HOME="${HOME}/.projects"
PROJECT_EXT=".project"
TMUXP_HOME="${HOME}/.tmuxp"
DEF_YAML="${TMUXP_HOME}/project.yaml"
HEADER_FORMAT='%-20s%-12s%-10s%-8s%-7s\n'
ROW_FORMAT='\e[1m%-20s\e[0m%-12s%-10s%8s\e[1m%7s\e[0m\n'
P_PRESENT=1
P_ACTIVE=2
P_SAVED=4

# Functions
version() {
  echo "projects, version ${VERSION}"
}

usage(){
  cat <<EOF
$(version)

$DESCR

Usage: $0 COMMAND [PROJECT_NAME]

COMMAND        Mandatory. Has to be one of:
               init   : Initiates a new project with PROJECT_NAME
               save   : Saves the last state of the project PROJECT_NAME
               resume : Resumes the project PROJECT_NAME
               info   : Prints information about the project PROJECT_NAME
               kill   : Kills the project PROJECT NAME
               list   : Lists all projects sorted by last accession dates
               help   : Prints this info
               version: Prints the version of the program

PROJECT_NAME   Name of the project, spaces are NOT allowed.

EOF
  exit 1
}


is_set() {
  [[ -n "${1}" ]] && local test_bid="${1}" || return 1
  if ((cur_info & test_bid)); then
    return 0
  else
    return 1
  fi
}

is_not_set() {
  [[ -n "${1}" ]] && local test_bid="${1}" || return 1
  if ((~cur_info & test_bid)); then
    return 0
  else
    return 1
  fi
}

protect() {
  echo "$2" > $1 && echo "$(date +"%Y-%m-%d")" >> $1 && chmod a-w $1
}

get_single_arg() {
  local arg_as_array=( $1 )
  local array_len=${#arg_as_array[@]}
  [ "${array_len}" -gt "1" ] && exit
  echo "${arg_as_array[0]}"
}

remove_lock() {
  [ -f "${1}" ] && /bin/rm -f "${1}"
}

declare -A date_created=()
declare -A date_accessed=()
declare -a all_projects=()
get_all_projects() {
  local prodat
  read -r -a prodat <<< $(find ${PROJECTS_HOME} -type f \
    -name *${PROJECT_EXT} -printf "%f %TY-%Tm-%Td\n" \
    | sed "s/${PROJECT_EXT}//g" | sort -k2r | tr '\n' ' ')
  for ((i=0;i<${#prodat[@]};i=i+2)); do
    j=$((i + 1))
    all_projects+=(${prodat[${i}]})
    date_accessed[${prodat[${i}]}]=${prodat[${j}]}
  done
}


# This great yaml parser is from
# https://gist.github.com/pkuczynski/8665367#file-parse_yaml-sh
parse_yaml() {
   local prefix=$2
   local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
   sed -ne "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
   awk -F$fs '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
         printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
      }
   }'
}

set_project_info() {
  local project_name=$1
  [ -z ${project_name} ] && return 1

  cur_project_base="${PROJECTS_HOME}/${project_name}"
  cur_project_yaml="${TMUXP_HOME}/${project_name}.yaml"
  cur_project_file="${cur_project_base}${PROJECT_EXT}"

  # Bit flags
  bits=0
  [ -f "${cur_project_file}" ] && bits=$((bits + P_PRESENT))
  [ -f "${cur_project_yaml}" ] && bits=$((bits + P_SAVED))
  tmux has-session -t =${project_name} >/dev/null 2>&1 && bits=$((bits + P_ACTIVE))
  cur_info=$bits

  # Read project file if exists
  if ((cur_info & P_PRESENT)); then
    readarray -t cur_project_info < ${cur_project_file}
  fi

  # Figure out project home dir
  if test "${cur_project_info[0]+isset}"; then
    cur_project_path="${cur_project_info[0]}"
  elif ((cur_info & P_SAVED)); then
    eval $(parse_yaml ${cur_project_yaml} "project_config_")
    [ -n "${project_config_windows_start_directory}" ] &&
      cur_project_path="${project_config_windows_start_directory}"
  fi
  [ -z "${cur_project_path}" ] && cur_project_path=$(pwd)

  # Check creation time
  if test "${cur_project_info[1]+isset}"; then
    date_created[$project_name]="${cur_project_info[1]}"
  else
    date_created[$project_name]="Unknown"
  fi
  # echo Path is "${cur_project_path}"
  # echo Info is "${cur_project_info[@]}"
  # echo Number is "${#cur_project_info[@]}"
  return 0
}

print_headers() {
    printf ${HEADER_FORMAT} "Project" "Created" "Accessed" " Saved" " Active"
    printf ${HEADER_FORMAT} "-------" "-------" "--------" " -----" " ------"
}

print_project_info() {
  local project_name=$1
  #local checkmark="...\xe2\x9c\x93"
  local checkmark="*"
  local is_saved
  local is_active
  [ -z ${project_name} ] && { echo "Need a PROJECT_NAME"; return 1; }
  set_project_info "${project_name}"
  local is_created="${date_created[${project_name}]}"
  local is_accessed="${date_accessed[${project_name}]}"
  [ -z ${is_created} ] && is_created=" --"
  is_set "${P_SAVED}" && is_saved="${checkmark}   " || is_saved=" "
  is_set "${P_ACTIVE}" && is_active="${checkmark}  " || is_active=" "
  printf ${ROW_FORMAT} "${project_name}" "${is_created}" "${is_accessed}" "${is_saved}" "${is_active}"
}

set_history_and_call_tmuxp() {
  export PROJECT_NAME=$1
  export PROMPT_COMMAND='echo -ne "\033]0;[ ${PROJECT_NAME} ]@${HOSTNAME}\007"'
  [ -n "$3" ] && cd "$3" && export PROJECT_HOME="$3"
  tmuxp load $2
  exit 0
}

set_history_and_call_tmux() {
  export PROJECT_NAME=$1
  export PROJECT_HOME="$2"
  export PROMPT_COMMAND='echo -ne "\033]0;[ ${PROJECT_NAME} ]@${HOSTNAME}\007"'
  tmux attach -t $1
  exit 0
}

# Set up variables
cur_command=$(get_single_arg "${1}")
cur_project=$(get_single_arg "${2}")

[ -z "${cur_command}" ] && usage
[ -d ${PROJECTS_HOME} ] || mkdir -p ${PROJECTS_HOME}
if [ -n "${cur_project}" ]; then
  set_project_info "${cur_project}"
  project_lock="${cur_project_base}.lock"
  lockfile -r 0 ${project_lock} || exit 1
  trap "remove_lock ${project_lock}; exit 1" 0 1 2 3 13 15
fi

# Execute the command
case "${cur_command}" in
  init)
    if is_set $P_PRESENT && (is_set $P_ACTIVE || is_set $P_SAVED); then
      echo "[${cur_project}] was already created. Either 'kill' this project or\
 'resume' to attach to tmux session or to load the last saved state"
      exit 0
    elif is_set $P_PRESENT; then
      echo "[${cur_project}] was already created. However; it is neither active\
 nor saved. Either first 'kill' then 'init' for a new project, or 'resume' to attach
 a new tmux session. In all cases, the project history file will be recovered, but
 last state is lost."
      exit 0
    elif is_set $P_ACTIVE && is_not_set $P_PRESENT; then
      read -r -p "[${cur_project}] is an active tmux session.  Attach to current\
 tmux session to initiate a project? [Y/n] " response
      case $response in
        [nN][oO]|[nN])
          exit 0
        ;;
        *)
          protect "${cur_project_file}" "${cur_project_path}"
          set_history_and_call_tmux ${cur_project} "${cur_project_path}"
        ;;
      esac
    elif is_set $P_SAVED && is_not_set $P_PRESENT; then
      echo "[${cur_project}] is not present but saved, which can be\
'resume'd to the last saved state."
      read -r -p "Do you want to initiate a new project? This will delete the old\
saved state! [y/N] " response
      case $response in
        [yY][eE][sS]|[yY])
          rm ${cur_project_yaml}
          set_project_info "${cur_project}"
          protect "${cur_project_file}" "${cur_project_path}"
          set_history_and_call_tmuxp ${cur_project} "${DEF_YAML}" "${cur_project_path}"
        ;;
        *)
          exit 0
        ;;
      esac
    else
      protect "${cur_project_file}" "${cur_project_path}"
      set_history_and_call_tmuxp ${cur_project} "${DEF_YAML}" "${cur_project_path}"
    fi
  ;;
  save)
    tmuxp freeze ${cur_project}
  ;;
  resume)
    if is_set $P_PRESENT && is_set $P_ACTIVE; then
      touch -m ${cur_project_file} && \
      set_history_and_call_tmux ${cur_project} "${cur_project_path}"
    elif is_set $P_PRESENT && is_set $P_SAVED; then
      echo "Resuming [${cur_project}] using ${cur_project_yaml}. Path is '${cur_project_path}'"
      touch -m ${cur_project_file} && \
      set_history_and_call_tmuxp ${cur_project} ${cur_project_yaml} "${cur_project_path}"
    elif is_set $P_PRESENT; then
      touch -m ${cur_project_file} && \
      set_history_and_call_tmuxp ${cur_project} "${DEF_YAML}" "${cur_project_path}"
    elif is_set $P_ACTIVE && is_not_set $P_PRESENT; then
      echo "[${cur_project}] is not present but there is an active tmux\
 session. Use 'init' to initiate a new project from that session"
    elif is_set $P_SAVED && is_not_set $P_PRESENT; then
      read -r -p "[${cur_project}] is not present but saved. Do you want to\
to resume to the last saved state - which will also initiate a new project?\
 [Y\n] " response
      case $response in
        [nN][oO]|[nN])
          exit 0
        ;;
        *)
          protect "${cur_project_file}" "${cur_project_path}"
          set_history_and_call_tmuxp ${cur_project} ${cur_project_yaml} "${cur_project_path}"
        ;;
      esac
    else
      echo "[${cur_project}] is not active and not saved. Can't resume, try 'init'"
      exit 1
    fi
  ;;
  info)
    get_all_projects
    print_headers
    print_project_info "${cur_project}"
    exit 0
  ;;
  kill)
    read -r -p "Are you sure that you want to kill [${cur_project}]? This\
 will remove all locks, saved states; only history files will remain.\
 [y/N] " response
    case $response in
      [yY][eE][sS]|[yY])
        rm -f ${cur_project_file}
        rm -f ${cur_project_yaml}
        tmux kill-session -t ${cur_project}
      ;;
      *)
        exit 0
      ;;
    esac
  ;;
  list)
    get_all_projects
    print_headers
    for key in "${all_projects[@]}"; do
      print_project_info "${key}"
    done
  ;;
  help)
    usage
    exit 0
  ;;
  version)
    version
    exit 0
  ;;
  *)
    echo "Command can be one of [init, save, resume, kill, list, info, help, version]"
    usage
  ;;
esac

